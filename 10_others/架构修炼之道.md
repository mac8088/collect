
## 架构修炼之道 -- 读书笔记

### C01 网关之道

#### 认识API网关

> 从单体应用到微服务的演变，我们引入了API Gateway

API网关的由来：

- 单体应用维护性差，牵一发动全身。
- 当单体满足不了逐渐增长的扩展需求，微服务就出现了。
- 微服务化后就必须有统一的入口和出口。
- 所有的API调用统一接入API网关层，由网关负责接入和输出。

[网关雏形](img/app_gateway1.png)

API网关的专注：

- 安全
- 流量
- 路由

一个与网关类似的东西 -- **代理**。 它们的区别：

- 代理是纯粹的数据传递，协议不会发生变化
- 网关在数据透传递情况下，还涉及到协议的转换

一个API网关的基本功能：

- 统一接入
- 协议适配
- 流量管控与容错
	- 限流、降级和熔断等容错的方式
- 安全防护
	- 防刷控制、黑白名单

API网关架构示例：

- 网关运行良好的环境还包括：注册中心。
- 为了实现动态配置，比如通过**ZooKeeper**读取发布的API接口。
- 为了实现高性能，比如将数据全部异构到**Redis**缓存。
- 为了提供网关的吞吐率，可以使用NIO + Servlet3 异步的方式。
- 访问日志的存储可以放在HBase中。
- 需要一个支持**OAuth2.0**的授权中心。
- 为了可以更轻量级地处理接入问题，引入**Nginx**+Lua做接入层。

[一个线上网关的整体架构图](img/app_gateway3.png)


#### 一个API的生命周期

> API，应用编程接口

- API作为一种可编程的应用接口，具备可设计、可测试的过程，有着完整的生命周期的。
- API设计工具有 RAML、 Swagger

RAML定义的生命周期：

- Design
- Build
- Test
- Document
- Share

Swagger定义的生命周期：

- Design
- Build
- Document
- Test
- Standardize

此书的作者又增加了两个过程： 运行、下线

生命周期的过程：

- 设计：设计是根本
	- 起个好名字，做到**见名知意**。
	- 入参和出参定义严格。
	- 注意不要公开不必要的参数。
- 构建：对API内部的逻辑进行编程。
- 文档：一份清晰度文档
	- **程序员最讨厌的两件事**：一是别人不写注释，二是自己写注释。
	- 目前RAML、 Swagger可以自动生成文档。
- 测试：好的API是可测试的。
- 分享: 分享实为发布。
- 运行：运行期间的重点工作就是：对API进行监控。
	- 性能监控
	- 可用率监控
	- 调用量监控
- 下线：生命周期的末尾， API下线或者版本更替。


#### API网关的基石

> 泛化调用，变得宽泛。

- **泛化**来自于**UML**所描述的四种关系。（泛化、实现、依赖和关联关系）
- 泛化是一个动词，变得宽泛。
- 泛化就是不具体，但是并不模糊。（喜欢这个解释）

泛化的作用：

- 使用者在调用提供者的接口的时候，**不再需要API提供者的客户端JAR包**，也就是**没有POJO**。
- 对于一个网关系统来说，如果调用N个接口，准备N个JAR包，这样的网关是难以维护的。

技术要点：

- 底层的原理和普通的RPC调用一样，网络、序列号、反射等技术一致。
- 区别在于参数和返回值中的所有POJO都用 **Map** 来表示。
- 可以参考alibaba 的 **Dubbo** 中 **GenericService**。
- 使用泛化调用的网关只需要基础RPC基础的**一个JAR即可**。

[网关的基石-泛化调用](img/gateway_generic.png)


#### 如果发布API到网关系统

> 网关系统不必依赖于RPC的存在,起初是两个世界的事物

- 如何让API发布到网关系统中?
- 实际问题是需要利用什么方法将RPC环境下的API让网关系统能够识别?

[网关是如何参合进来的?](img/gateway_rpc_3.png)

技术思路:

- 以上面的泛化为基础，将API通过一种方式存储到网关系统能够访问的数据存储中。
- 为了提高系统的性能，这种数据存储一般会选择Redis。
- 网关系统提供一个**API发布平台入口**，让API发布者将RPC环境下的API数据录入到此平台。
- 可以在用户输入服务的类名后通过RPC接口获取要发布的所有信息:
	- 方法
	- 入参
	- 出参
	- 注释
	- 接口负责人
- 剩下的工作就可以让API网关做泛化调用了.

[网关是如何参合进来的?](img/gateway_rpc_4.png)


#### 管道技术

> 一条笔直的马路，直达服务提供者。

- 这条“马路”上会有各种“检查”。
- 但是最终是一条马路一个方向。
- 为了处理类似的各种检查，可以引入**管道**的概念。

将参数校验、黑白名单、限流控制、接口调用等都封装在一个个管道，并且按照顺序组织起来。

[管道技术](img/gateway_pipeline1.png)

管道的实现：

- 定义各个功能的 **Pipe** 类
- 将Pipe类包装成一个实现了Runable的 **PipeTask**
- 将PipeTask交给事先定义好的ThreadPool线程池来处理

[管道实现](img/gateway_pipeline2.png)

管道信息传递：

- 管道之间需要支持信息传递。
- 信息传递是单向的。
- 传递的顺序依靠管道池里面管道排列顺序。
- 利用封装的**PipeInput**实现信息的传递。
- PipeInput对象最好是 **immutable** 的，各个管道中**保持最新对象**。

[管道信息传递](img/gateway_pipeline3.png)

管道的优点：

- 代码结构清晰，减少if else逻辑判断。
- 管道链是一个主流程，主流程和子流程之间脉络清晰。
- 对管道功能可以进行**热插拔**，比如去掉黑白名单的管道。

[管道的优点](img/gateway_pipeline4.png)

责任链模式:

- 管道的思想和责任链模式实际上是类似的。
- 管道技术是责任链模式的一种思维演化。
- 它们的区别在于：
	- 管道技术更加灵活
	- 责任链的使用方式相对受限
- 平时使用的过滤器或者拦截器也是属于管道技术的应用。
- 管道链最好是可以支持管道编排，类似于工作流。


#### 一个传统网关系统的几种死法


#### Servlet3 异步原理与实践

> 做网关需要有一种异步的思维。

对于一个网关来说，除了第一次I/O线程之外，还需要再发送一次I/O请求，调用接口提供方的服务。


#### 全异步网关


#### 脱库和多级缓存


#### 热更新


#### 网关的七种武器


### C02 开发之道


### C03 分布式之道

#### 认识分布式


#### 分布式事务


#### 分布式锁


#### 分布式限流


#### 衡量性能的指标

指标：

- QPS Queries Per Second 查询量/秒
- TPS Transaction Per Second， 每秒事务处理数量
- RT, Response Time 响应时间，我们在使用时候一般用**平均响应时间**。
- 并发数： 系统能够同时处理的查询请求数量或事务数量。

响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。

- 请求发送时间
- 网络传输时间
- 服务器处理时间

TPS和QPS的计算公式：

	TPS = 并发数 / 平均响应时间
	QPS = 并发数 / 平均响应时间

QPS、响应时间、并发数三者之间的关系如图：

![并发数与QPS](img/perf_qps.png)

由二八原则计算机器数量：

- 根据**二八原则**，系统流量也不例外，20%的时间承载流80%的流量。
- 线上系统每天80%的访问集中在20%的时间里，这20%时间叫：**峰值时间**。
- 利用这一点来评估系统扩容时候需要增加的机器。

公式如下：

	（总PV数 × 80%） / （每天秒数 × 20%） = 峰值时间内每秒请求数（QPS）
	 峰值时间内每秒请求数 / 单台机器的QPS  = 需要的机器



### C04 MQ之道

### C05 消息推送之道

### C06 RPC之道

### C07 I/O之道

### C08 微服务之道


### C09 容错之道


### C10 程序之外